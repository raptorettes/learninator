// Generated by CoffeeScript 1.7.0
(function() {
  var Nodefn, W, browserify, coffeeify, exorcist, fs, mold, path, through, uglifyify, _;

  path = require('path');

  fs = require('fs');

  W = require('when');

  _ = require('lodash');

  browserify = require('browserify');

  exorcist = require('exorcist');

  through = require('through2');

  Nodefn = require('when/node');

  uglifyify = require('uglifyify');

  coffeeify = require('coffeeify');

  mold = require('mold-source-map');

  module.exports = function(opts) {
    var Browserify;
    opts = _.defaults(opts, {
      files: 'js/main.js',
      opts: {
        extensions: ['.js', '.json', '.coffee']
      },
      minify: false,
      sourceMap: false,
      transforms: [coffeeify]
    });
    if (opts.out == null) {
      throw new Error("you must provide an 'out' path");
    }
    opts.out = path.normalize(opts.out);
    opts.files = Array.prototype.concat(opts.files);
    opts.transforms = Array.prototype.concat(opts.transforms);
    return Browserify = (function() {

      /**
       * Sets up the custom category, maps all paths to the project root,
       * and initializes browserify and the coffee transform.
       *
       * @param  {Function} @roots - Roots class instance
       */
      function Browserify(roots) {
        var t, _i, _len, _ref;
        this.roots = roots;
        this.category = 'browserify';
        this.deps = [];
        this.files = opts.files.map((function(_this) {
          return function(f) {
            return path.join(_this.roots.root, f);
          };
        })(this));
        this.b = browserify({
          entries: this.files,
          extensions: ['.js', '.json', '.coffee'],
          debug: opts.sourceMap
        });
        _ref = opts.transforms;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          t = _ref[_i];
          this.b.transform(t);
        }
        if (opts.minify) {
          this.b.transform(uglifyify, {
            global: true
          });
        }
      }


      /**
       * Gets the dependency graph of required files so we can ignore them
       * from the compile process.
       *
       * @return {Promise} promise for finishing getting the deps
       */

      Browserify.prototype.setup = function() {
        var deferred;
        deferred = W.defer();
        this.b.pipeline.get('deps').push(through.obj((function(_this) {
          return function(row, enc, next) {
            _this.deps = _this.deps.concat(row.file);
            return next();
          };
        })(this), function() {
          return deferred.resolve();
        }));
        this.b.bundle();
        return deferred.promise;
      };


      /**
       * If the file was passed directly into browserify or it is a dependency
       * of one of the main files, extract from the roots pipeline because
       * browserify is going to handle the compilation.
       */

      Browserify.prototype.fs = function() {
        return {
          extract: true,
          detect: (function(_this) {
            return function(f) {
              return _.contains(_this.files, f.path) || _.contains(_this.deps, f.path);
            };
          })(this)
        };
      };


      /**
       * Zero out the contents so nothing is compiled and don't write the file.
       * Browserify will take care of this instead.
       */

      Browserify.prototype.compile_hooks = function() {
        return {
          before_file: function(ctx) {
            return ctx.content = '';
          },
          write: function() {
            return false;
          }
        };
      };


      /**
       * Run browserify logic.
       *
       * @todo if output folder doesnt exist, create it?
       * @todo wrap output with UMD?
       */

      Browserify.prototype.category_hooks = function() {
        return {
          after: (function(_this) {
            return function(ctx) {
              var deferred, map_path, out_path, stream, writer;
              deferred = W.defer();
              out_path = path.join(_this.roots.config.output_path(), opts.out);
              stream = _this.b.bundle();
              if (opts.sourceMap) {
                map_path = out_path.replace(path.extname(out_path), '') + '.js.map';

                /*
                 * Convert output paths to be relative
                 * to roots project instead of absolute paths
                 * https://github.com/substack/node-browserify/issues/663
                 */
                stream = stream.pipe(mold.transformSourcesRelativeTo(_this.roots.root || '')).pipe(exorcist(map_path));
              }
              writer = fs.createWriteStream(out_path);
              stream.pipe(writer);
              stream.on('error', deferred.reject);
              writer.on('error', deferred.reject);
              writer.on('finish', deferred.resolve);
              return deferred.promise;
            };
          })(this)
        };
      };

      return Browserify;

    })();
  };

}).call(this);
